doctype html
html(lang="en")
  head
    meta(charset="UTF-8")
    meta(name="viewport", content="width=device-width, initial-scale=1.0")
    title Food Diary Entry
    link(rel="stylesheet", href="/static/styles.css")
    script(
      src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js",
      defer
    )
    script(
      src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"
    )
    script(src="/static/app.js")
  body(x-data="foodDiaryApp()", x-init="initApp()")
    // Login page for unauthenticated users
    .login-container(x-show="!isAuthenticated")
      .login-card
        h1 Food Diary
        p Welcome! Please sign in with your GitHub account to continue.
        button.login-button(@click="login") 
          | ðŸ™ Sign in with GitHub

    // Main app for authenticated users
    .app-container(x-show="isAuthenticated")
      header
        .header-top
          h1 Food Diary
          .user-info
            img.user-avatar(
              x-show="userInfo?.avatar_url",
              :src="userInfo?.avatar_url",
              :alt="userInfo?.username"
            )
            span.user-name(x-text="userInfo?.name || userInfo?.username")
            button.logout-button(@click="logout") Logout
          .sync-controls
            button.sync-button(
              @click="syncWithServer",
              :disabled="syncStatus === 'syncing'"
            )
              span(x-show="syncStatus === 'idle'") ðŸ”„ Sync
              span(x-show="syncStatus === 'syncing'") â³ Syncing...
              span(x-show="syncStatus === 'error'") âŒ Sync Error
            button.export-button(
              @click="exportData",
              :disabled="entries.length === 0"
            ) ðŸ“¦ Export
            .online-status(:class="{ offline: !navigator.onLine }")
              span(x-show="navigator.onLine") ðŸŸ¢ Online
              span(x-show="!navigator.onLine") ðŸ”´ Offline
        nav.nav-tabs
          button.nav-tab(
            :class="{ active: currentView === 'entry' }",
            @click="currentView = 'entry'"
          ) New Entry
          button.nav-tab(
            :class="{ active: currentView === 'history' }",
            @click="currentView = 'history'"
          ) History

        .view-container(x-show="currentView === 'entry'")
          h2 Add New Entry
          .food-diary-form
            .form-group
              label.form-label(for="note") Note:
              textarea#note.form-textarea(
                x-model="note",
                rows="4",
                placeholder="Enter your food notes..."
              )

            .form-group
              .checkbox-container
                input#custom-datetime-checkbox.form-checkbox(
                  type="checkbox",
                  x-model="useCustomDatetime"
                )
                label.form-label(for="custom-datetime-checkbox") Set custom date/time

              .datetime-input-container(x-show="useCustomDatetime")
                label.form-label(for="event-datetime") Event Date & Time:
                input#event-datetime.form-datetime-input(
                  type="datetime-local",
                  x-model="eventDatetime"
                )

            .form-group
              label.form-label(for="photo") Photo:
              input#photo.form-file-input(
                type="file",
                accept="image/*",
                @change="handlePhotoUpload($event)"
              )

            .form-group(x-show="photoPreview")
              h3 Photo Preview:
              img.photo-preview(:src="photoPreview", alt="Photo preview")

            .form-group
              button.save-button(
                @click="saveEntry",
                :disabled="!note && !photoBase64"
              ) Save Entry

        .view-container(x-show="currentView === 'history'")
          h2 Entry History
          .history-container
            template(x-for="entry in entries", :key="entry.id")
              .entry
                .entry-header
                  .entry-timestamp(
                    x-text="formatTimestamp(entry.event_datetime)"
                  )
                  button.delete-button(@click="deleteEntry(entry.id)") Ã—
                .entry-content
                  p.entry-text(x-text="entry.text")
                  .entry-photo(x-show="entry.photo")
                    img(:src="entry.photo", alt="Food photo")
            .empty-history(x-show="entries.length === 0")
              p No entries yet. Add your first food diary entry!

    //- You can link to static JS files here, e.g.:
    //- script(src="/static/script.js")

    script.
      function foodDiaryApp() {
        return {
          currentView: "entry",
          note: "",
          useCustomDatetime: false,
          eventDatetime: "",
          photoBase64: null,
          photoPreview: null,
          entries: [],
          syncStatus: "idle", // idle, syncing, error
          isAuthenticated: #{ is_authenticated },
          userInfo: #{ user },
          apiStagePath: #{ api_stage_path },

          async initApp() {
            if (!this.isAuthenticated) {
              return; // Don't initialize app data if not authenticated
            }
            try {
              await foodDiaryUtils.initDB(); // This calls initDB from static/app.js
              await this.loadEntries(); // Load existing entries
              await this.syncWithServer(); // Initial sync
              console.log("Alpine component initialized, DB connection ready via static/app.js.");
            } catch (error) {
              console.error("Alpine component: Failed to initialize DB via static/app.js:", error);
              alert("Database initialization failed. App may not function correctly.");
            }
          },

          async syncWithServer() {
            if (this.syncStatus === "syncing") return; // Prevent concurrent syncs

            this.syncStatus = "syncing";
            try {
              await foodDiaryUtils.syncWithServer();
              await this.loadEntries(); // Refresh entries after sync
              this.syncStatus = "idle";
            } catch (error) {
              console.error("Sync failed:", error);
              this.syncStatus = "error";
              // Don't show alert for sync errors - just log them
            }
          },

          async loadEntries() {
            try {
              this.entries = await foodDiaryUtils.readAllEntriesFromDB();
              console.log("DEBUG: Loaded entries from DB:", this.entries);
              console.log("DEBUG: Number of entries:", this.entries.length);
              // Sort by event_datetime, newest first
              this.entries.sort((a, b) => new Date(b.event_datetime) - new Date(a.event_datetime));
              console.log("DEBUG: After sorting:", this.entries);
            } catch (error) {
              console.error("Error loading entries:", error);
            }
          },

          formatTimestamp(eventDatetime) {
            const date = new Date(eventDatetime);
            return date.toLocaleDateString() + " " + date.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
          },

          async deleteEntry(entryId) {
            if (!confirm("Are you sure you want to delete this entry?")) {
              return;
            }
            try {
              // Delete from local database
              await foodDiaryUtils.deleteEntryFromDB(entryId);
              // Also try to delete from server
              await foodDiaryUtils.deleteEntryOnServer(entryId);
              await this.loadEntries(); // Refresh the list
            } catch (error) {
              console.error("Error deleting entry:", error);
              alert("Error deleting entry. Check console for details.");
            }
          },

          handlePhotoUpload(event) {
            const file = event.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (e) => {
                this.photoBase64 = e.target.result;
                this.photoPreview = e.target.result;
              };
              reader.onerror = (e) => {
                console.error("FileReader error:", e);
                alert("Error reading file.");
                this.photoBase64 = null;
                this.photoPreview = null;
              };
              reader.readAsDataURL(file);
            } else {
              this.photoBase64 = null;
              this.photoPreview = null;
            }
          },

          async saveEntry() {
            if (!this.note && !this.photoBase64) {
              alert("Please enter a note or select a photo to save.");
              return;
            }

            const entryData = {
              timestamp: new Date().toISOString(),
              event_datetime: this.useCustomDatetime && this.eventDatetime ? new Date(this.eventDatetime).toISOString() : new Date().toISOString(),
              text: this.note,
              photo: this.photoBase64,
            };

            try {
              const newEntryId = await foodDiaryUtils.saveEntryToDB(entryData); // Calls saveEntryToDB from static/app.js
              console.log("Alpine component: Entry saved successfully with ID:", newEntryId);
              alert(`Entry saved! Data: ${JSON.stringify({ text: this.note, photo: this.photoBase64 ? "has photo" : "no photo", event_datetime: entryData.event_datetime })}`);
              this.note = "";
              this.useCustomDatetime = false;
              this.eventDatetime = "";
              this.photoBase64 = null;
              this.photoPreview = null;
              // Reset file input
              const photoInput = document.getElementById("photo");
              if (photoInput) {
                photoInput.value = null;
              }
              // Refresh entries list and switch to history view
              await this.loadEntries();
              this.currentView = "history";
            } catch (error) {
              console.error("Alpine component: Error saving entry via static/app.js:", error);
              alert("Error saving entry. Check console for details.");
            }
          },

          async exportData() {
            try {
              const zip = new JSZip();

              // Create JSON data without photos for the main export
              const exportEntries = this.entries.map((entry) => ({
                id: entry.id,
                timestamp: entry.timestamp,
                event_datetime: entry.event_datetime,
                text: entry.text,
                hasPhoto: !!entry.photo,
                synced: entry.synced,
              }));

              // Add JSON file
              zip.file("entries.json", JSON.stringify(exportEntries, null, 2));

              // Add images folder and extract photos
              const imagesFolder = zip.folder("images");
              let imageCount = 0;

              for (const entry of this.entries) {
                if (entry.photo) {
                  // Extract base64 data and file extension
                  const matches = entry.photo.match(/^data:image\/([a-zA-Z]+);base64,(.+)$/);
                  if (matches) {
                    const extension = matches[1];
                    const base64Data = matches[2];
                    const fileName = `entry_${entry.id}_${entry.event_datetime.split("T")[0]}.${extension}`;
                    imagesFolder.file(fileName, base64Data, { base64: true });
                    imageCount++;
                  }
                }
              }

              // Generate and download zip
              const content = await zip.generateAsync({ type: "blob" });
              const url = window.URL.createObjectURL(content);
              const link = document.createElement("a");
              link.href = url;
              link.download = `food-diary-export-${new Date().toISOString().split("T")[0]}.zip`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
              window.URL.revokeObjectURL(url);

              alert(`Export complete! Downloaded ${this.entries.length} entries with ${imageCount} images.`);
            } catch (error) {
              console.error("Export failed:", error);
              alert("Export failed. Check console for details.");
            }
          },

          async login() {
            window.location.href = `${this.apiStagePath}/auth/login`;
          },

          async logout() {
            try {
              await fetch(`${this.apiStagePath}/auth/logout`, { method: "POST" });
              window.location.href = `${this.apiStagePath}/`;
            } catch (error) {
              console.error("Logout failed:", error);
              window.location.href = `${this.apiStagePath}/auth/logout`;
            }
          },

          // Functions to use readAllEntriesFromDB or markEntryAsSyncedInDB can be added here
          // when UI elements for those actions are implemented. For example:
          /*
          async loadAllEntries() {
            try {
              const entries = await foodDiaryUtils.readAllEntriesFromDB();
              // Process entries, e.g., display them
              console.log("Loaded entries:", entries);
            } catch (error) {
              console.error("Alpine: Error loading entries", error);
            }
          },
          async markEntrySynced(entryId) {
            try {
              await foodDiaryUtils.markEntryAsSyncedInDB(entryId);
              console.log(`Alpine: Marked entry ${entryId} as synced`);
              // Update UI accordingly
            } catch (error) {
              console.error(`Alpine: Error marking entry ${entryId} as synced`, error);
            }
          }
          */
        };
      }
